# 프로젝트 설명
DTO로 쓰는 객체들은 그 객체에 primary key를 가지고 있는 경우가 있습니다.
객체 자체가 키값을 내포하고 있기 때문에, List, Map 구분없이 사용하려면 사용할 수 있다고 생각했습니다.

만약 객체가 primary key(의미상) 를 포함하고 있다면, List, Map 구분없이 사용할 수 있도록 할 수 있는 범용적으로 활용할 수 있는 인터페이스, 구현체를 만드는것이 목표입니다.

## 목표
- map은 순서가 없는 비선형 자료구조이고, list는 순서가 있는 선형 자료구조입니다. 비선형 자료구조를 선형으로 바꿀 수 있는 로직이 필요합니다.
- 또한 List보다는 Map은 Set에 가까운 자료구조입니다. Set과 List의 간격은 어떻게 매울것인지 생각해야합니다.
- (공통) primary key를 가진다는것을 알리려면 아래와 같은 인터페이스를 DTO가 상속받아 구현해야합니다.
```java
public interface PrimaryKeyAccessable<T> {
	T getPrimaryKey();
}
```
- 제네릭을 통해 위 인터페이스를 구현한 객체만 Map <-> List 구분없이 사용할 수 있음을 알릴 수 있습니다. `<K, T extends PrimaryKeyAccessable<K>>`

### 첫번째 시도
1. Map와 List의 구현체를 각각 만들었습니다. MyArrayList, MyHashMap 등등..
2. 그리고 그 새로운 Map, List에 필요한 쿼리를 날릴 수 있는 공통 인터페이스를 제정하였습니다. (MyJDBC)
3. 문제는 기존 구현체들을 활용하지 않고 새로 만들어야 했습니다. (재사용성이 매우 떨어짐)

### 두번째 시도
1. List, Map을 묶는 상위 인터페이스인 MapList라는 인터페이스와 ListLike같은 인터페이스를 새롭게 만들어서 새로운 계층구조를 만들어 해결하려고 했습니다.
2. List, Map 인터페이스를 조작할 수 없어서 실효성이 없는 방법이었습니다.

### 세번째 시도
1. Map객체를 덮어서 List로 변환하는 Proxy객체를 만들었습니다.
2. 간단하고 문제를  Map만을 List로 부분적으로 변환합니다. 다만, 사용하는 사용자가 MapProxy()라는것을 명시적으로 사용해야하기 때문에 조금 거추장 스러운 부분이 있습니다.

### 네번째 시도
1. 선형 자료구조의 인터페이스가 접근 편리성이 있기 때문에, 이런 프로젝트가 시작된것이므로.. List로 완전히 바꾸는것을 목표로 하지 말고, List처럼 쉽게 접근 가능한 다른 인터페이스(ListLike) 타입을 만드는것을 고려해볼 수 있습니다.
2. 이 방법은 기존의 비선형, 중복보장 등의 근본적인 규칙을 깨지 않으면서 List의 '일부' 간편한 Set, Map 자료구조에서 활용해볼 수 있습니다. 
3. 첫번째 시도와 세번쨰 시도를 적절히 섞은 솔루션입니다.
```java
public interface ListLike<T> {
	// C
	void add(T t);
	// R
	void get(T t);
	// U
	void update(T prev, T next);
	// D
	void delete(T t);
}
```
파사드 패턴?
